{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"about me","text":"<p>You can find me on the earth.</p>"},{"location":"home/","title":"Welcome to Cool Spy's Site","text":"<p>This is my home.</p>"},{"location":"home/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"home/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"study/cs/datastructure/","title":"Data structure","text":""},{"location":"study/cs/datastructure/#graph","title":"Graph","text":"<p>!!! Overall Introduction: The graph is powerful tool to handle many practical problems, especially the routine management ones, like crossing the river. There are may algorithms, both referred to in the data structure course and discrete mathematics courses. The theory and the relative proofs are indeed important, which verifies the validity of these algorithms. However, as for my current situation, I think the most urgent thing is to know how to implement the in code.  </p>"},{"location":"study/cs/datastructure/#dfs-and-its-application","title":"DFS and its application","text":"<p>DFS is used to traverse the graph, each vertex only once, and it will give a spanning tree if we record the edges throughout the whole process.</p> <p>Here is the general code: The graph here is a UDAG(undirected acyclic) and unweighted.</p> <pre><code>void DFS(int G[][], int v, int Nv, int visited[] ){\n    visited[v]=1;\n    for(int i=0; i&lt;Nv; i++){\n        if( G[v][i]&amp;&amp;!visited[i] ){\n            DFS(G, i, Nv, visited);\n        }\n    }\n}\n</code></pre>"},{"location":"study/cs/datastructure/#topological-sort","title":"Topological Sort","text":"<p>The graph is a DAG, unweighted and connected.</p> <pre><code>int top=0;\nvoid DFS(int a[][], int v, int Nv, int visited[], int stack){\n    visited[v]=true;\n    for(int i=0;i&lt;Nv;i++){\n        if(a[v][i]&amp;&amp;!visited[i]){\n            DFS(a, i, Nv, visited);\n        }\n    }\n    stack[top++]=v;\n}\nvoid topologcial_sort(int G[][], int Nv){\n    int stack[Nv];\n    int visited[Nv];\n    for(int i=0;i&lt;Nv;i++){\n        visited[i]=0;\n    }\n    DFS(G, 0, Nv, visited, stack);\n    while(top&gt;-1){\n        printf(\"%d \",stack[top--]);\n    }\n}\n</code></pre>"},{"location":"study/cs/datastructure/#circle-detection","title":"Circle detection","text":""},{"location":"study/cs/datastructure/#strongly-connected-components-computation","title":"Strongly Connected components computation","text":"<p>Tarjan\u7b97\u6cd5\u662f\u7528\u6765\u5728\u6709\u5411\u56fe\u4e2d\u5bfb\u627e\u5f3a\u8fde\u901a\u5206\u91cf\uff08Strongly Connected Components, SCC\uff09\u7684\u7ecf\u5178\u7b97\u6cd5\u3002\u5f3a\u8fde\u901a\u5206\u91cf\u662f\u6307\u4e00\u4e2a\u6709\u5411\u56fe\u4e2d\u7684\u4e00\u4e2a\u6700\u5927\u5b50\u56fe\uff0c\u5176\u4e2d\u6bcf\u4e00\u5bf9\u9876\u70b9\u90fd\u53ef\u4ee5\u4e92\u76f8\u5230\u8fbe\u3002Tarjan\u7b97\u6cd5\u662f\u57fa\u4e8e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08DFS\uff09\u7684\uff0c\u5e76\u4e14\u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5b8c\u6210\uff08O(V + E)\uff09\u3002</p>"},{"location":"study/cs/datastructure/#tarjan","title":"Tarjan\u7b97\u6cd5\u7684\u4e3b\u8981\u601d\u60f3","text":"<p>Tarjan\u7b97\u6cd5\u4f7f\u7528\u4e00\u4e2a\u6808\u548c\u4e00\u4e9b\u8f85\u52a9\u6570\u7ec4\u6765\u8bb0\u5f55\u9876\u70b9\u7684\u8bbf\u95ee\u72b6\u6001\u3002\u5728DFS\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e2a\u9876\u70b9\u90fd\u88ab\u5206\u914d\u4e86\u4e00\u4e2a\u552f\u4e00\u7684\u7f16\u53f7\uff08DFS\u7f16\u53f7\uff09\u548c\u4e00\u4e2a\u6700\u4f4e\u53ef\u8fbe\u7f16\u53f7\uff08Low-link\u503c\uff09\u3002\u901a\u8fc7\u8fd9\u4e9b\u7f16\u53f7\uff0c\u53ef\u4ee5\u5224\u65ad\u9876\u70b9\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u3002</p>"},{"location":"study/cs/datastructure/#_1","title":"\u7b97\u6cd5\u6b65\u9aa4","text":"<ol> <li>\u521d\u59cb\u5316\uff1a\u8bbe\u7f6eDFS\u7f16\u53f7\u3001Low-link\u503c\u7b49\u8f85\u52a9\u6570\u7ec4\uff0c\u5e76\u521d\u59cb\u5316\u6808\u3002</li> <li>DFS\u904d\u5386\uff1a\u5bf9\u6bcf\u4e2a\u672a\u8bbf\u95ee\u7684\u9876\u70b9\u6267\u884cDFS\uff0c\u9012\u5f52\u5730\u8bbf\u95ee\u6240\u6709\u53ef\u8fbe\u7684\u9876\u70b9\u3002</li> <li>\u66f4\u65b0Low-link\u503c\uff1a\u5728DFS\u8fc7\u7a0b\u4e2d\u66f4\u65b0\u5f53\u524d\u9876\u70b9\u548c\u5176\u540e\u7ee7\u9876\u70b9\u7684Low-link\u503c\u3002</li> <li>\u8bc6\u522b\u5f3a\u8fde\u901a\u5206\u91cf\uff1a\u5f53\u53d1\u73b0\u4e00\u4e2a\u9876\u70b9\u7684DFS\u7f16\u53f7\u548cLow-link\u503c\u76f8\u7b49\u65f6\uff0c\u5b83\u662f\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u7684\u6839\u8282\u70b9\uff0c\u5c06\u6808\u4e2d\u6240\u6709\u5230\u8fbe\u8be5\u9876\u70b9\u7684\u9876\u70b9\u5f39\u51fa\uff0c\u5f62\u6210\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> </ol>"},{"location":"study/cs/datastructure/#_2","title":"\u4f2a\u4ee3\u7801","text":"<p>\u4e0b\u9762\u662fTarjan\u7b97\u6cd5\u7684\u4f2a\u4ee3\u7801\uff1a</p> <pre><code>// n \u662f\u56fe\u4e2d\u7684\u9876\u70b9\u6570\nindex = 0\nstack = []\nindices = [-1] * n\nlowlink = [0] * n\nonStack = [False] * n\nSCCs = []\n\nfunction strongconnect(v):\n    indices[v] = index\n    lowlink[v] = index\n    index += 1\n    stack.push(v)\n    onStack[v] = True\n\n    // \u8003\u8651 v \u7684\u6bcf\u4e2a\u540e\u7ee7\u9876\u70b9 w\n    for each (v, w) in edges:\n        if indices[w] == -1:\n            // w \u8fd8\u672a\u8bbf\u95ee\u8fc7\uff0c\u9012\u5f52\u8bbf\u95ee\u5b83\n            strongconnect(w)\n            lowlink[v] = min(lowlink[v], lowlink[w])\n        else if onStack[w]:\n            // w \u5728\u6808\u4e2d\uff0c\u662f\u4e00\u4e2a\u56de\u8fb9\n            lowlink[v] = min(lowlink[v], indices[w])\n\n    // \u5982\u679c v \u662f\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u7684\u6839\u8282\u70b9\n    if lowlink[v] == indices[v]:\n        SCC = []\n        while True:\n            w = stack.pop()\n            onStack[w] = False\n            SCC.append(w)\n            if w == v:\n                break\n        SCCs.append(SCC)\n\nfor each v in vertices:\n    if indices[v] == -1:\n        strongconnect(v)\n\nreturn SCCs\n</code></pre>"},{"location":"study/cs/datastructure/#c","title":"C\u8bed\u8a00\u5b9e\u73b0","text":"<p>\u4e0b\u9762\u662fTarjan\u7b97\u6cd5\u5728C\u8bed\u8a00\u4e2d\u7684\u5b9e\u73b0\uff1a</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\n#define MAX 100\n\nint index = 0, n;\nint indices[MAX], lowlink[MAX];\nbool onStack[MAX];\nint stack[MAX], stackTop = -1;\nint graph[MAX][MAX];\nint SCC[MAX][MAX], SCCIndex = 0, SCCSizes[MAX];\n\nvoid push(int v) {\n    stack[++stackTop] = v;\n    onStack[v] = true;\n}\n\nint pop() {\n    int v = stack[stackTop--];\n    onStack[v] = false;\n    return v;\n}\n\nvoid strongconnect(int v) {\n    indices[v] = lowlink[v] = index++;\n    push(v);\n\n    for (int w = 0; w &lt; n; w++) {\n        if (graph[v][w]) {\n            if (indices[w] == -1) {\n                strongconnect(w);\n                lowlink[v] = lowlink[v] &lt; lowlink[w] ? lowlink[v] : lowlink[w];\n            } else if (onStack[w]) {\n                lowlink[v] = lowlink[v] &lt; indices[w] ? lowlink[v] : indices[w];\n            }\n        }\n    }\n\n    if (lowlink[v] == indices[v]) {\n        int w;\n        do {\n            w = pop();\n            SCC[SCCIndex][SCCSizes[SCCIndex]++] = w;\n        } while (w != v);\n        SCCIndex++;\n    }\n}\n\nvoid tarjan() {\n    for (int i = 0; i &lt; n; i++) {\n        indices[i] = -1;\n        lowlink[i] = 0;\n        onStack[i] = false;\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        if (indices[i] == -1) {\n            strongconnect(i);\n        }\n    }\n}\n\nint main() {\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &amp;n);\n\n    printf(\"Enter the adjacency matrix:\\n\");\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            scanf(\"%d\", &amp;graph[i][j]);\n        }\n    }\n\n    tarjan();\n\n    printf(\"Strongly Connected Components:\\n\");\n    for (int i = 0; i &lt; SCCIndex; i++) {\n        printf(\"SCC %d: \", i + 1);\n        for (int j = 0; j &lt; SCCSizes[i]; j++) {\n            printf(\"%d \", SCC[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"study/cs/datastructure/#_3","title":"\u89e3\u91ca","text":"<ol> <li>\u521d\u59cb\u5316\uff1a\u8bbe\u7f6eDFS\u7f16\u53f7\u6570\u7ec4<code>indices</code>\u548cLow-link\u503c\u6570\u7ec4<code>lowlink</code>\uff0c\u521d\u59cb\u5316\u6808\u548c\u76f8\u5173\u6807\u8bb0\u3002</li> <li>\u9012\u5f52\u51fd\u6570 <code>strongconnect</code>\uff1a\u6267\u884cDFS\uff0c\u66f4\u65b0Low-link\u503c\uff0c\u5e76\u5728\u53d1\u73b0\u5f3a\u8fde\u901a\u5206\u91cf\u65f6\uff0c\u5c06\u6808\u4e2d\u76f8\u5173\u9876\u70b9\u5f39\u51fa\uff0c\u5f62\u6210\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> <li>\u4e3b\u51fd\u6570 <code>tarjan</code>\uff1a\u5bf9\u6bcf\u4e2a\u672a\u8bbf\u95ee\u7684\u9876\u70b9\u8c03\u7528\u9012\u5f52\u51fd\u6570<code>strongconnect</code>\u3002</li> <li>\u8f93\u5165\u8f93\u51fa\uff1a\u5728<code>main</code>\u51fd\u6570\u4e2d\u8bfb\u53d6\u9876\u70b9\u6570\u91cf\u548c\u90bb\u63a5\u77e9\u9635\uff0c\u8c03\u7528<code>tarjan</code>\u7b97\u6cd5\uff0c\u8f93\u51fa\u627e\u5230\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> </ol> <p>Kosaraju-Sharir\u7b97\u6cd5\u662f\u4e00\u79cd\u7528\u4e8e\u5728\u6709\u5411\u56fe\u4e2d\u5bfb\u627e\u5f3a\u8fde\u901a\u5206\u91cf\uff08Strongly Connected Components, SCC\uff09\u7684\u7ecf\u5178\u7b97\u6cd5\u3002\u8be5\u7b97\u6cd5\u57fa\u4e8e\u4e24\u6b21\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08DFS\uff09\uff0c\u5176\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(V + E)\uff0c\u5176\u4e2dV\u662f\u9876\u70b9\u6570\uff0cE\u662f\u8fb9\u6570\u3002</p>"},{"location":"study/cs/datastructure/#kosaraju-sharir","title":"Kosaraju-Sharir\u7b97\u6cd5\u6b65\u9aa4","text":"<ol> <li>\u53cd\u8f6c\u56fe\uff1a\u9996\u5148\u53cd\u8f6c\u56fe\u4e2d\u7684\u6240\u6709\u8fb9\uff0c\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u56fe\u3002</li> <li>\u7b2c\u4e00\u6b21DFS\uff1a\u5bf9\u539f\u56fe\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u9876\u70b9\u7684\u5b8c\u6210\u65f6\u95f4\u3002</li> <li>\u7b2c\u4e8c\u6b21DFS\uff1a\u6309\u7167\u7b2c\u4e00\u6b21DFS\u7684\u5b8c\u6210\u65f6\u95f4\u7684\u9006\u5e8f\u5bf9\u53cd\u8f6c\u56fe\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff0c\u627e\u5230\u6240\u6709\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> </ol>"},{"location":"study/cs/datastructure/#_4","title":"\u7b97\u6cd5\u4f2a\u4ee3\u7801","text":"<pre><code>function kosarajuSharir(G):\n    let G_rev be the reverse of graph G\n    let S be an empty stack\n    let visited be a map from node to boolean\n\n    // First DFS: Record the finish time of each node\n    function dfs1(v):\n        visited[v] = true\n        for each neighbor w of v in G:\n            if not visited[w]:\n                dfs1(w)\n        S.push(v)\n\n    // Second DFS: Collect nodes in the same SCC\n    function dfs2(v, component):\n        visited[v] = true\n        component.add(v)\n        for each neighbor w of v in G_rev:\n            if not visited[w]:\n                dfs2(w, component)\n\n    // Initialize the visited map and run the first DFS\n    for each vertex v in G:\n        visited[v] = false\n    for each vertex v in G:\n        if not visited[v]:\n            dfs1(v)\n\n    // Reinitialize the visited map for the second DFS\n    for each vertex v in G:\n        visited[v] = false\n\n    // Process all nodes in the order defined by the stack S\n    let SCCs be an empty list of components\n    while S is not empty:\n        v = S.pop()\n        if not visited[v]:\n            let component be an empty list\n            dfs2(v, component)\n            SCCs.append(component)\n\n    return SCCs\n</code></pre>"},{"location":"study/cs/datastructure/#c_1","title":"C\u8bed\u8a00\u5b9e\u73b0","text":"<p>\u4ee5\u4e0b\u662fKosaraju-Sharir\u7b97\u6cd5\u7684C\u8bed\u8a00\u5b9e\u73b0\uff1a</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\n#define MAX 100\n\nint graph[MAX][MAX];\nint graph_rev[MAX][MAX];\nbool visited[MAX];\nint stack[MAX];\nint stackTop = -1;\nint SCC[MAX][MAX], SCCIndex = 0, SCCSizes[MAX];\nint n;\n\nvoid push(int v) {\n    stack[++stackTop] = v;\n}\n\nint pop() {\n    return stack[stackTop--];\n}\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int w = 0; w &lt; n; w++) {\n        if (graph[v][w] &amp;&amp; !visited[w]) {\n            dfs1(w);\n        }\n    }\n    push(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    SCC[SCCIndex][SCCSizes[SCCIndex]++] = v;\n    for (int w = 0; w &lt; n; w++) {\n        if (graph_rev[v][w] &amp;&amp; !visited[w]) {\n            dfs2(w);\n        }\n    }\n}\n\nvoid kosarajuSharir() {\n    // Step 1: Run DFS on the original graph to fill the stack\n    for (int i = 0; i &lt; n; i++) {\n        visited[i] = false;\n    }\n    for (int i = 0; i &lt; n; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    // Step 2: Reverse the graph\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            graph_rev[i][j] = graph[j][i];\n        }\n    }\n\n    // Step 3: Run DFS on the reversed graph in the order defined by the stack\n    for (int i = 0; i &lt; n; i++) {\n        visited[i] = false;\n    }\n    while (stackTop != -1) {\n        int v = pop();\n        if (!visited[v]) {\n            SCCSizes[SCCIndex] = 0;\n            dfs2(v);\n            SCCIndex++;\n        }\n    }\n}\n\nint main() {\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &amp;n);\n\n    printf(\"Enter the adjacency matrix:\\n\");\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            scanf(\"%d\", &amp;graph[i][j]);\n        }\n    }\n\n    kosarajuSharir();\n\n    printf(\"Strongly Connected Components:\\n\");\n    for (int i = 0; i &lt; SCCIndex; i++) {\n        printf(\"SCC %d: \", i + 1);\n        for (int j = 0; j &lt; SCCSizes[i]; j++) {\n            printf(\"%d \", SCC[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"study/cs/datastructure/#_5","title":"\u89e3\u91ca","text":"<ol> <li>\u521d\u59cb\u5316\u548c\u8f93\u5165\uff1a\u8bfb\u53d6\u9876\u70b9\u6570\u91cf\u548c\u90bb\u63a5\u77e9\u9635\uff0c\u521d\u59cb\u5316\u76f8\u5173\u6570\u7ec4\u548c\u53d8\u91cf\u3002</li> <li>\u7b2c\u4e00\u6b21DFS\uff1a\u5bf9\u539f\u56fe\u6267\u884cDFS\uff0c\u6309\u7167\u5b8c\u6210\u65f6\u95f4\u5c06\u9876\u70b9\u538b\u5165\u6808\u4e2d\u3002</li> <li>\u56fe\u53cd\u8f6c\uff1a\u751f\u6210\u53cd\u8f6c\u56fe\uff0c\u5c06\u56fe\u4e2d\u7684\u6bcf\u6761\u8fb9\u65b9\u5411\u53cd\u8f6c\u3002</li> <li>\u7b2c\u4e8c\u6b21DFS\uff1a\u6309\u7167\u7b2c\u4e00\u6b21DFS\u7684\u5b8c\u6210\u65f6\u95f4\u7684\u9006\u5e8f\u5bf9\u53cd\u8f6c\u56fe\u6267\u884cDFS\uff0c\u627e\u5230\u6240\u6709\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> <li>\u8f93\u51fa\u7ed3\u679c\uff1a\u8f93\u51fa\u6240\u6709\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u3002</li> </ol>"}]}